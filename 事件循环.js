// 一个进程就是一个内存空间
// 一个进程有多个线程来做不同的事情
// 浏览器是多进程多线程应用程序
// 浏览器包含浏览器进程、网络进程、渲染进程等，为了避免各个模块相互影响，连环崩坏，浏览器启动多个进程
// 浏览器进程：浏览器界面、用户交互、子进程管理等，用多个线程处理不同任务
// 网络进程：网络资源加载
// 渲染进程：启动渲染主线程、主线程负责执行html、css、js
// 浏览器为每个标签页开启一个渲染进程、避免标签页之间相互影响


// 渲染主线程干什么：
// 解析html
// 解析css
// 计算样式
// 布局
// 处理图层
// 执行js
// 执行事件处理
// 执行计时器回调函数
// ...



// 主线程如何调度任务：排队
// 渲染主线程
// 消息队列
// 其他进程
// 开始时渲染主线程进入一个无限循环
// 每次循环会检查消息队列里，如果有，取出第一个任务执行，执行完进入下一次循环，如果没有进入休眠
// 其他所有线程可以随时向消息队列加任务，加到末尾，在添加时如果主线程休眠，唤醒主线程拿取任务




// 异步？
// 无法立即执行的任务：setTimeout、setInterval、XHR、Fetch、addEventListener...
// 如果等待这些任务，造成阻塞
// 计时线程、交互线程
// 计时结束加到消息队列


// 如何理解js的异步
// js单线程、执行在浏览器渲染主线程中、渲染主线程只有一个
// 主线程承担诸多工作，（上述主线程干什么）
// 如果使用同步、可能导致主线程产生阻塞、导致消息队列中的任务无法执行
// 这样主线程在白白浪费时间、页面无法更新等，卡死
// 浏览器使用异步
// 异步发生时，主线程将任务交给其他线程处理，自身结束任务执行，执行后续代码
// 当其他线程任务执行结束，将事先传递的回调函数包装成任务，加到消息队列末尾，等待主线程调用
// 这样的模式下，浏览器永不阻塞，保证单线程的流畅运行


// js为什么阻塞渲染？
// 全部运行在主线程上



// 任务有优先级么？
// 任务没有，消息队列有
// 宏队列、微队列（新：同一个任务类型在一个队列）
// 微队列任务优先执行
// 微队列（Promise、MutationObserver）
// 目前chrome至少包含下列队列：
// 延时队列：存放计时器回调任务（优先级：中）
// 交互队列：存放用户操作事件处理任务（优先级：高）
// 微队列：最快需要执行的任务（优先级：最高）



// js事件循环
// 浏览器渲染主线程的工作方式
// chrome开启时，启动一个无限循环
// 每次循环会检查消息队列里，如果有，取出第一个任务执行，执行完进入下一次循环，如果没有进入休眠
// 其他所有线程可以随时向消息队列加任务，加到末尾，在添加时如果主线程休眠，唤醒主线程拿取任务
// 消息队列分为宏队列、微队列（新：同一个任务类型在一个队列）
// 微队列任务优先执行

















